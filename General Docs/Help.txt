========
Synopsis
========

The SpikeGLX API accesses the SpikeGLX program via TCP/IP. On top of that, our message exchange protocol implements acknowledgement, validation and error reporting. SpikeGLX.exe and the API client can run on the same Windows machine or across a network.

The lowest latency is achieved with SpikeGLX.exe and Windows client using loopback address 127.0.0.1. Note that WSL2 allows Linux to run under Windows, but that is within a virtual machine that has a separate loopback address, so don't choose loopback for that configuration.

The API provides extensive control over a running SpikeGLX process: starting and stopping a run, setting parameters, fetching live data, calling the Par2 and SHA1 tools, and so on. Everything you need to integate SpikeGLX into your workflow.

The core technology is implemented in C++. All other languages are layered on top of the C++ core. C++ clients will have the lowest possible latency because native data types can be used throughout, which bypasses type conversion and extra data copying.

A session begins when an API client program creates a connection handle, which is then passed to all API functions. All subsequent network communication with the SpikeGLX server process is handled automatically within the DLL.

A connection handle is weakly stateful: merely keeping a handle to a network socket. A network connection cleans up after itself on the server side after 10 seconds of inactivity. By the way, if your script has paused longer than 10 seconds, and you reuse a handle that has timed out, the API will automatically reestablish a connection and the script will likely continue without problems. Note that reestablishing a connection (if needed) may take several tens of milliseconds. You can change the timeout value in the SpikeGLX Command Server Settings window.

The API should support multithreaded clients, as long as each thread or subprocess is using its own connection handle.

==========================================
C++ Examples (similar for other languages)
==========================================

void *hSglx = sglx_createHandle_std();  // create a connection handle
sglx_connect( hSglx );                  // connect to SpikeGLX running on local machine

cppClient_sglx_get_keyvals  g_kv;       // container for getting params
sglx_getParams( g_kv, hSglx );          // optionally retrieve run params as (key, value) pairs

cppClient_sglx_set_keyvals  s_kv;       // container for setting params
s_kv.mstrstr["niMNChans1"] = "0:5";
s_kv.mstrstr["niDualDevMode"] = "false";
sglx_setParams( hSglx, s_kv );          // make changes

sglx_startRun( hSglx );                 // start data acquisition run using last-set params
sglx_stopRun( hSglx );                  // stop run

sglx_close( hSglx );                    // release network resources
sglx_destroyHandle( hSglx );            // release memory resources

========
(js, ip)
========

The two integer values (js, ip) select a data stream.
js: stream type: {0=nidq, 1=obx, 2=imec-probe}.
ip: substream:   {0=nidq (if js=0), 0+=which OneBox or imec probe}.

If you enable filtered IM stream buffers (on IM Setup tab), you can
retrieve those data using js=-2 in either the fetch or fetchLatest
calls. Although the data fetched are filtered, the js=2 and js=-2
stream counterparts have identical characteristics: SN, channels,
sample rate, sample count, and everything else. Therefore, all calls
except fetch internally replace js=-2 with js=2, which allows you to
pass js=-2 to any call without triggering an error.

Examples (js, ip):
(0, 0) = nidq.	// for nidq, ip is arbitrary but zero by convention
(1, 4) = obx4.
(2, 7) = imec7.
Note: ip has range [0..np-1], where, np is queried using getStreamNP().

===================
Validate Parameters
===================

Validation entails applying self-consistency checks to the totality of settings (parameters) that configure the currently selected hardware.

You'll find that the majority of API functions by necessity modify settings, so will complain if you haven't done a validation yet. An initial validation needs to be done once per launch of the SpikeGLX application. Thereafter, it is done inherently by the setParamsXXX functions and others as needed. The initial validation can be done two ways:

Using the GUI
=============
1. Open the 'Configure' dialog in SpikeGLX (Ctrl+N).
2. Use the 'Enable' checkboxes on the 'Devices' tab to select hardware, then 'Detect'.
3. Optionally, visit the other tabs and review or edit choices for your experiment.
4. Click either 'Run' or 'Verify|Save'.

Either button performs a complete validation check, and if successful, all the settings in the dialog are saved as the current working set.

The 'Detect' operation assigns logical-ip numbers to each selected probe and OneBox stream. These are shown in the 'Probe Table'. The API commands to get or set parameters make reference to these ip values, so take note of which is which.

Using SelectDevices
===================
1. Call SelectDevices with a devstring parameter that specifies which hardware to enable according to physical(slot,port,dock) addresses.

The SelectDevices function:
- Opens the 'Configure' dialog.
- Checks boxes according to the devstring parameter.
- Clicks 'Detect', and if successful...
- Clicks 'Verify|Save' which validates and saves a current working set.

You'll still need to know the logical-ip values for the selections:
2. Call getProbeAddrs and getOneBoxAddrs get logical-to-physical address mappings.

==================
Explore Parameters
==================

You can learn what parameters are available by using the getXXX calls. You can also look at their disk files, which are in a few locations:

- 'SpikeGLX/_Configs/daq.ini'
- 'SpikeGLX/_Calibration/imec_probe_settings.ini'
- 'SpikeGLX/_Calibration/imec_onebox_settings.ini'.

Open the ini files in a text editor. You'll see several subgroups of settings. This is a good way to see the exact spelling, case, and value type of the items you can read and write via the API. Examples of accessing the subgroups:

- Group [DAQSettings]:                getParams()
- Group [DAQ_Imec_All]:               getParamsImecCommon()
- Group [SerialNumberToProbe]/SNjjj:  getParamsImecProbe()
- Group [SerialNumberToOneBox]/SNjjj: getParamsOneBox()


